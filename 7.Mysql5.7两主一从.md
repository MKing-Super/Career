# Mysql5.7两主一从

## 1.步骤

master1

```
# 编辑配置文件
vi /etc/my.cnf


# 添加以下内容：
[mysqld]
server-id = 1  # 服务器唯一ID，主从不能重复
log_bin = master1-bin  # 开启二进制日志
binlog_format = ROW  # 使用ROW格式的binlog
binlog-do-db = work  # 只同步db1数据库（按需修改）
expire_logs_days = 7  # binlog保留7天
sync_binlog = 1  # 每次事务提交都同步binlog到磁盘



systemctl restart mysqld


-- 登录MySQL
mysql -u root -p

-- 创建专门用于复制的用户
CREATE USER 'repl1'@'10.50.10.111' IDENTIFIED BY '666666';

-- 授予复制权限
GRANT REPLICATION SLAVE ON *.* TO 'repl1'@'10.50.10.111';

-- 刷新权限
FLUSH PRIVILEGES;

-- 查看master状态，记录File和Position值
SHOW MASTER STATUS;
```

master2

```
vi /etc/my.cnf


[mysqld]
server-id = 2  # 不同于其他节点
log_bin = master2-bin
binlog_format = ROW
binlog-do-db = life  # 同步db2数据库
expire_logs_days = 7
sync_binlog = 1



systemctl restart mysqld



mysql -u root -p

CREATE USER 'repl2'@'10.50.10.111' IDENTIFIED BY '666666';
GRANT REPLICATION SLAVE ON *.* TO 'repl2'@'10.50.10.111';
FLUSH PRIVILEGES;
SHOW MASTER STATUS;  -- 记录File和Position
```

slave

```
vi /etc/my.cnf

[mysqld]
server-id = 3  # 唯一ID
relay_log = relay-bin  # 中继日志
log_bin = slave-bin  # 开启binlog（可选）

# 多源复制配置
master-info-repository = TABLE  # 将master信息存储到表中
relay-log-info-repository = TABLE  # 将relay log信息存储到表中

# 复制过滤规则
replicate-do-db = work  # 只复制db1（来自Master1）
replicate-do-db = life  # 只复制db2（来自Master2）

# 设置全局只读（不影响本地创建的表）
# read_only = ON
# super_read_only = ON  # 防止超级用户写入

# 忽略系统库复制
replicate-ignore-db = mysql
replicate-wild-ignore-table = mysql.%



systemctl restart mysqld


mysql -u root -p

-- 配置Master1的复制通道
CHANGE MASTER TO
MASTER_HOST='10.50.10.109',  -- Master1的IP地址
MASTER_USER='repl1',  -- Master1创建的复制用户
MASTER_PASSWORD='666666',  -- 复制用户密码
MASTER_LOG_FILE='master1-bin.000001',  -- Master1的File值
MASTER_LOG_POS=771,  -- Master1的Position值
MASTER_PORT=3306  -- MySQL端口
FOR CHANNEL 'master1';  -- 通道名称

-- 配置Master2的复制通道
CHANGE MASTER TO
MASTER_HOST='10.50.10.110',
MASTER_USER='repl2',
MASTER_PASSWORD='666666',
MASTER_LOG_FILE='master2-bin.000001',
MASTER_LOG_POS=771
FOR CHANNEL 'master2';

-- 启动所有复制通道
START SLAVE;

-- 查看复制状态（所有通道）
SHOW SLAVE STATUS\G

-- 查看指定通道状态
SHOW SLAVE STATUS FOR CHANNEL 'master1'\G
```

创建本地管理账号

```
-- master1
CREATE USER 'mk_work'@'%' IDENTIFIED BY '123';
-- 读写 work（本地表）
GRANT ALL PRIVILEGES ON work.* TO 'mk_work'@'%';
-- 去除权限
-- REVOKE ALL PRIVILEGES ON work.* FROM 'mk_work'@'%';
-- 立即生效
FLUSH PRIVILEGES;
-- 看权限
SHOW GRANTS FOR 'mk_work'@'%';


-- master2
CREATE USER 'mk_life'@'%' IDENTIFIED BY '123';
-- 读写 life（本地表）
GRANT ALL PRIVILEGES ON life.* TO 'mk_life'@'%';
-- 去除权限
-- REVOKE ALL PRIVILEGES ON life.* FROM 'mk_life'@'%';
-- 立即生效
FLUSH PRIVILEGES;
-- 看权限
SHOW GRANTS FOR 'mk_life'@'%';


-- slave
-- 创建本地管理用户（允许创建数据库和表），'%'表示允许从任何主机连接
CREATE USER 'mk_home'@'%' IDENTIFIED BY '111111';

-- 授予所有权限（不包括GRANT OPTION）
GRANT ALL PRIVILEGES ON *.* TO 'mk_home'@'%';

-- 只授予查询权限work,life（同步表）
GRANT SELECT ON work.* TO 'mk_home'@'%';
GRANT SELECT ON life.* TO 'mk_home'@'%';
-- 读写home（本地表）
GRANT ALL PRIVILEGES ON home.* TO 'mk_home'@'%';
-- 看权限
SHOW GRANTS FOR 'mk_home'@'%';
```

sql

```sql
-- master1
CREATE DATABASE work;
use work;
CREATE TABLE `work`.test (
    id INT,            
    name VARCHAR(20)    
);

-- master2
CREATE DATABASE life;
use life;
CREATE TABLE `life`.life_test (
    id INT,            
    name VARCHAR(20)    
);


-- slave
CREATE DATABASE home;
use home;
CREATE TABLE `home`.test (
    id INT,            
    name VARCHAR(20)    
);
```





## 2.异常排除

### 2.1 1032

**人为制造方法：**

```
-- 从库root改同步表的数据
UPDATE test SET `name` = 'mkmk' WHERE id = 2;
```

**解决方法：**

1 salve

```
SHOW SLAVE STATUS\G
SHOW SLAVE STATUS FOR CHANNEL 'master1'\G

STOP SLAVE;
```

> 报错：
>
> Last_SQL_Error: Could not execute Update_rows event on table work.test; Can't find record in 'test', Error_code: 1032; handler error HA_ERR_END_OF_FILE; the event's master log master1-bin.000002, end_log_pos 1200

2 master1

```
SHOW MASTER STATUS;
```

> +--------------------+----------+--------------+------------------+-------------------+
> | File               | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
> +--------------------+----------+--------------+------------------+-------------------+
> | master1-bin.000002 |     1231 | work         |                  |                   |
> +--------------------+----------+--------------+------------------+-------------------+
> 1 row in set (0.00 sec)

```
-- master1 锁定所有表为只读状态，确保在备份期间没有数据变化
FLUSH TABLES WITH READ LOCK;

-- 先确认binlog事件分布：
mysqlbinlog --no-defaults \
--base64-output=decode-rows \
/usr/local/mysql/data/master1-bin.000002 | grep -n "^# at"
```

> 4:# at 4
> 8:# at 123
> 11:# at 154
> 15:# at 219
> 28:# at 291
> 30:# at 341
> 32:# at 393
> 35:# at 424
> 39:# at 489
> 44:# at 561
> 46:# at 611
> 48:# at 663
> 51:# at 694
> 55:# at 759
> 60:# at 831
> 62:# at 881
> 64:# at 932
> 67:# at 963
> 71:# at 1028
> 76:# at 1100
> 78:# at 1150
> 80:# at 1200

```
-- 导出log文件
mysqlbinlog --no-defaults \
--base64-output=decode-rows -v -v \
--start-position=1100 \
--stop-position=1200 \
/usr/local/mysql/data/master1-bin.000002 > conflict.log

-- 直接查看
mysqlbinlog --no-defaults \
--base64-output=decode-rows -v -v \
--start-position=1100 \
--stop-position=1200 \
/usr/local/mysql/data/master1-bin.000002 | less
```

> /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
> /*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
> DELIMITER /*!*/;
> \# at 1100
> \#250716 21:57:15 server id 1 end_log_pos 1150 CRC32 0x8053a1e3     Table_map: `work`.`test` mapped to number 108
> \# at 1150
> \#250716 21:57:15 server id 1 end_log_pos 1200 CRC32 0xea6800ae     Update_rows: table id 108 flags: STMT_END_F
> \### UPDATE `work`.`test`
> \### WHERE
> \###  @1=2 /* INT meta=0 nullable=1 is_null=0 */
> \###  @2='1' /* VARSTRING(80) meta=80 nullable=1 is_null=0 */
> \### SET
> \###  @1=2 /* INT meta=0 nullable=1 is_null=0 */
> \###  @2='2' /* VARSTRING(80) meta=80 nullable=1 is_null=0 */
> SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
> DELIMITER ;
> \# End of log file
> /*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
> /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;

3 slave

```
-- 查看 test 表结构
SHOW CREATE TABLE `work`.test;


CREATE TABLE `test` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci


-- 查看更新位置数据是否正确（主从库对比修正数据）
SELECT * 
FROM `work`.test
WHERE id = 2;
-- root
UPDATE test SET `name` = '2' WHERE id = 2;

-- 根据主库状态更新点位
CHANGE MASTER TO
MASTER_HOST='10.50.10.109',  -- Master1的IP地址
MASTER_USER='repl1',  -- Master1创建的复制用户
MASTER_PASSWORD='666666',  -- 复制用户密码
MASTER_LOG_FILE='master1-bin.000002',  -- Master1的File值
MASTER_LOG_POS=1231,  -- Master1的Position值
MASTER_PORT=3306  -- MySQL端口
FOR CHANNEL 'master1';

START SLAVE;
```

master1

```
-- master1（释放之前设置的表锁，允许主服务器继续正常写入）
UNLOCK TABLES;
```

slave

```
SHOW SLAVE STATUS\G
```



## 3.其他

3.1 主库加索引，从库会同步过去吗？

​		是。在MySQL主库上对表添加索引时，这个操作会通过二进制日志(binlog)同步到所有从库。

```sql
-- master1
ALTER TABLE `work`.test ADD INDEX idx_name (name);
-- DROP INDEX idx_name ON `work`.test;
ALTER TABLE `work`.test ADD INDEX idx_all (id,name);
-- DROP INDEX idx_all ON `work`.test;

-- 查看
SHOW INDEX FROM `work`.test;


-- slave
SHOW INDEX FROM `work`.test;
```

3.2 主从库同一条数据字段不一致，但主库不对此数据进行更新操作会导致主从同步终止吗？

不会。

1. **单纯数据不一致（无后续更新）**
   - 如果主库不再修改这条不一致的数据
   - 从库不会主动检测数据一致性
   - 复制线程会继续正常工作
   - **同步不会终止**，但数据不一致状态会持续存在
2. **不一致数据未被复制事件涉及**
   - 后续所有操作都不涉及这条不一致数据
   - 复制进程不会发现不一致问题

如果后续的更新操作涉及此条数据则导致主从同步中止。

> 主从 SELECT * FROM `work`.test; 中 id=2 的数据不一致。
>
> ```
> UPDATE `work`.test SET name = 'change' WHERE id > 0;
> ```
>
> 更新后会导致主从不一致。

